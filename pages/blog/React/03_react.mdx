---
title: 03. 메모이제이션
---

## 메모이제이션

동일한 계산을 반복할때 해당 내용을 메모리에 저장해둠으로서, 동일한 계산의 반복 수행을 제거하여 실행속도를 빠르게하는 기술이다.

리액트에서는 `state`가 변하는 등 컴포넌트가 재렌더링 되는 경우가 빈번하다. 하지만 실제 해당 데이터가 변하지않았는데, 재렌더링이 발생한다면, 최적화를 할 필요성이 있을 것이다.

그럴때 사용하는 훅이 `useMemo`, `useCallback`이다.

### useMemo

`useMemo`는 메모이제이션 된 `값`을 반환한다.

쉽게 말해서, 이미 연산된 값을 다시 연산하지않고, 재사용한다고 이해하면 되겠다.

```jsx
const memoizedValue = useMemo(() => {
    resultValue(a, b);
}, [a, b]); //deps
```

`useEffect`와 기본 구성자체는 같다. 콜백함수를 가지고 해당 콜백에 의존하는 배열을 지닌다.

-   배열이 존재하지 않을 경우 매 렌더링마다 계산한다.

### useCallback

`useCallback`은 메모이제이션 된 `함수` 를 반환한다.

쉽게 말해서, 이미 연산된 함수를 다시 연산하지않고, 재사용한다.

만약 게시글의 리스트를 불러오는 함수가 존재한다고 해보자,

이미 함수는 연산이 완료 되었지만 게시글이 등록되거나 삭제되는 경우 항상 재렌더링이 될 것이다. 기존의 데이터는 그대로 있되, 변하게되는 게시글만 재렌더링하는 방식으로 사용할 경우, 훨씬 경제적이라고 할 수 있다.

```jsx
const onCreate = useCallback((content) => {
    dispatch({
        type: 'CREATE',
        data: {
            id: new Date().getTime(),
            isDone: false,
            content: content,
            date: new Date().getTime(),
        },
    });
}, []);
```

내가 작성하였던 투두리스트를 예시로 들어보자. 해

당 투두리스트의 생성은 투두리스트를 생성할 때 말고는 다시 계산 될 필요성이 없다.

따라서 위와같이 활용될 수 있다.

### memo()

`memo`는 이름이 비슷하여 햇갈릴 수 있으나, 이는 HOC`(Higher-Order Components`)다.

HOC란 컴포넌트를 인자로서 받아 새로운 컴포넌트를 다시 return 해주는 함수를 의미한다.

일반적인 컴포넌트는 인자로 받은 props를 UI에 활용하지만, HOC는 새로운 별도의 컴포넌트를 만든다.

일종의 패턴이라고 보면된다, 좀더 자세히 이야기해보자.

만약 특정 컴포넌트가 같은 `props`를 받을 때 같은 결과를 렌더링을 한다면 굳이 불필요한 렌더링을 할 필요성이 없어진다. 이럴때 사용하는게 `memo` 함수다.

기본적으로는 값이 동등한지 여부를 확인하지만, 이 확인하는 방식이 얕은 비교에 불과하기때문에

함수, 객체는 사용자는 같다고 판단하더라도 컴퓨터는 같다고 판단하지 못한다!

그런 경우에는 정상적으로 작동하지 않으므로, 수동으로 값을 지정해주거나,

상단에 소개한 `useCallback`을 활용하는게 확실할 것이다.

```jsx
function component(props) {
 (...)
}

export default memo(component)
```

-   memo는 `HOC`, useMemo는 `Hook`이다.
-   기능적으로는 동일하나, `useMemo`는 `Hook`이기때문에 클래스형 컴포넌트에서 작동하지 못한다.

![sample](/img/2024-05-21-11-08-35.png)
